import { Router, Request, Response } from 'express';
import { UserModel } from '../models/User.model';
import { VerificationCodeModel } from '../models/VerificationCode.model';
import { EmailService } from '../services/email.service';
import { generateToken } from '../utils/jwt.util';
import { validateSignup, validateLogin, validateEmail, validateVerifyCode, validatePasswordReset, validatePasswordResetVerify } from '../middleware/validation.middleware';
import { authenticate } from '../middleware/auth.middleware';
import { SignupRequest, LoginRequest, AuthResponse } from '../types/user.types';
import bcrypt from 'bcryptjs';

const router = Router();

// Helper function to get UserModel instance (lazy initialization)
function getUserModel(): UserModel {
  return new UserModel();
}

// Helper function to get VerificationCodeModel instance
function getVerificationCodeModel(): VerificationCodeModel {
  return new VerificationCodeModel();
}

// Helper function to generate a random 4-digit code
function generateVerificationCode(): string {
  return Math.floor(1000 + Math.random() * 9000).toString();
}

// Helper function to generate a random password
function generatePassword(): string {
  const length = 8;
  const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let password = '';
  // Ensure at least one of each required type
  password += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)]; // uppercase
  password += 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)]; // lowercase
  password += '0123456789'[Math.floor(Math.random() * 10)]; // number
  
  // Fill the rest randomly
  for (let i = password.length; i < length; i++) {
    password += charset[Math.floor(Math.random() * charset.length)];
  }
  
  // Shuffle the password
  return password.split('').sort(() => Math.random() - 0.5).join('');
}

// Resend verification code endpoint
router.post('/resend-verification', validateEmail, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    const verificationCodeModel = getVerificationCodeModel();
    
    const { email } = req.body;

    // Check if user exists
    const user = await userModel.findByEmail(email);
    if (!user) {
      res.status(404).json({
        success: false,
        error: 'User not found',
        code: 'USER_NOT_FOUND',
      });
      return;
    }

    // If user is already verified, don't send verification code
    if (user.emailVerified) {
      res.status(400).json({
        success: false,
        error: 'Email is already verified',
        code: 'ALREADY_VERIFIED',
      });
      return;
    }

    // Generate new verification code and password
    const verificationCode = generateVerificationCode();
    const autoGeneratedPassword = generatePassword();
    const hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);

    // Update user's password with new one
    await userModel.updatePassword(user.uid, hashedPassword);

    // Store new verification code
    await verificationCodeModel.createVerificationCode(email, verificationCode, autoGeneratedPassword, hashedPassword);

    // Send validation email (code only, password will be sent after verification)
    try {
      await EmailService.sendValidationCode(email, user.firstName, verificationCode);
    } catch (emailError) {
      console.error('Failed to send validation email:', emailError);
      res.status(500).json({
        success: false,
        error: 'Failed to send verification email',
        code: 'EMAIL_SEND_FAILED',
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: 'Verification code has been resent. Please check your email.',
      data: {
        email: user.email,
      },
    });
  } catch (error) {
    console.error('Resend verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to resend verification code',
      code: 'RESEND_FAILED',
    });
  }
});

// Signup endpoint - creates user and sends validation email with code and password
router.post('/signup', validateSignup, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    const verificationCodeModel = getVerificationCodeModel();
    
    const { email, firstName, lastName, timeZone } = req.body;

    // Check if email already exists
    const existingUser = await userModel.findByEmail(email);
    if (existingUser) {
      // If user exists but is unverified, allow resending verification code
      if (!existingUser.emailVerified) {
        // Generate new verification code and password
        const verificationCode = generateVerificationCode();
        const autoGeneratedPassword = generatePassword();
        const hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);

        // Update user's password with new one
        await userModel.updatePassword(existingUser.uid, hashedPassword);

        // Store new verification code
        await verificationCodeModel.createVerificationCode(email, verificationCode, autoGeneratedPassword, hashedPassword);

        // Send validation email (code only, password will be sent after verification)
        try {
          await EmailService.sendValidationCode(email, existingUser.firstName, verificationCode);
        } catch (emailError) {
          console.error('Failed to send validation email:', emailError);
        }

        res.status(200).json({
          success: true,
          message: 'Verification code has been resent. Please check your email.',
          data: {
            email: existingUser.email,
            emailVerified: false,
          },
        });
        return;
      } else {
        res.status(409).json({
          success: false,
          error: 'Email already in use',
          code: 'EMAIL_IN_USE',
        });
        return;
      }
    }

    // Generate verification code and password
    const verificationCode = generateVerificationCode();
    const autoGeneratedPassword = generatePassword();
    const hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);

    // Create user with emailVerified: false and temporary password
    const data: SignupRequest = {
      email,
      firstName,
      lastName,
      timeZone,
    };

    // Create user with temporary password (will be updated after verification)
    const user = await userModel.createUserWithPassword(data, hashedPassword);

    // Store verification code with both plain and hashed password
    await verificationCodeModel.createVerificationCode(email, verificationCode, autoGeneratedPassword, hashedPassword);

    // Send validation email with code only (password will be sent after verification)
    try {
      await EmailService.sendValidationCode(email, firstName, verificationCode);
    } catch (emailError) {
      console.error('Failed to send validation email:', emailError);
      // Don't fail the signup, but log the error
      // User can request a new code later
    }

    res.status(201).json({
      success: true,
      message: 'Registration successful. Please check your email for the validation code.',
      data: {
        email: user.email,
        emailVerified: false,
      },
    });
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === 'Email already in use') {
        res.status(409).json({
          success: false,
          error: error.message,
          code: 'EMAIL_IN_USE',
        });
        return;
      }
    }

    console.error('Signup error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to register user',
      code: 'REGISTRATION_FAILED',
    });
  }
});

// Verify code endpoint - verifies code and sends welcome email with password
router.post('/verify-code', validateVerifyCode, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    const verificationCodeModel = getVerificationCodeModel();
    
    const { email, code } = req.body;

    // Find verification code
    const verification = await verificationCodeModel.findByEmailAndCode(email, code);
    
    if (!verification) {
      res.status(400).json({
        success: false,
        error: 'Invalid or expired verification code',
        code: 'INVALID_CODE',
      });
      return;
    }

    // Find user
    const user = await userModel.findByEmail(email);
    if (!user) {
      res.status(404).json({
        success: false,
        error: 'User not found',
        code: 'USER_NOT_FOUND',
      });
      return;
    }

    // Update user: set emailVerified to true and update password
    await userModel.updateEmailVerified(user.uid, true);
    await userModel.updatePassword(user.uid, verification.hashedPassword);

    // Mark verification code as used
    await verificationCodeModel.markAsVerified(email, code);

    // Send welcome email with password
    try {
      await EmailService.sendWelcomeEmail(email, user.firstName, verification.password);
    } catch (emailError) {
      console.error('Failed to send welcome email:', emailError);
      // Still mark as verified even if email fails
    }

    res.status(200).json({
      success: true,
      message: 'Email verified successfully. Please check your email for your password.',
      data: {
        email: user.email,
        emailVerified: true,
      },
    });
  } catch (error) {
    console.error('Verify code error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify code',
      code: 'VERIFICATION_FAILED',
    });
  }
});

// Login endpoint
router.post('/login', validateLogin, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    const data: LoginRequest = {
      email: req.body.email,
      password: req.body.password,
    };

    const user = await userModel.findByEmail(data.email);

    if (!user) {
      res.status(401).json({
        success: false,
        error: 'Invalid email or password',
        code: 'INVALID_CREDENTIALS',
      });
      return;
    }

    // Check if user is unverified
    if (!user.emailVerified) {
      res.status(403).json({
        success: false,
        error: 'Email not verified. Please verify your email to continue.',
        code: 'EMAIL_NOT_VERIFIED',
        data: {
          email: user.email,
          emailVerified: false,
        },
      });
      return;
    }

    const isPasswordValid = await userModel.verifyPassword(user, data.password);

    if (!isPasswordValid) {
      res.status(401).json({
        success: false,
        error: 'Invalid email or password',
        code: 'INVALID_CREDENTIALS',
      });
      return;
    }

    // Generate JWT token
    const token = generateToken({
      uid: user.uid,
      email: user.email,
      role: user.role,
    });

    const response: AuthResponse = {
      token,
      user: {
        uid: user.uid,
        email: user.email,
        username: user.username,
        firstName: user.firstName,
        lastName: user.lastName,
        emailVerified: user.emailVerified,
        role: user.role,
        teams: user.teams,
      },
    };

    res.status(200).json({
      success: true,
      message: 'Login successful',
      data: response,
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to login',
      code: 'LOGIN_FAILED',
    });
  }
});

// Forgot password endpoint - sends password reset code
router.post('/forgot-password', validatePasswordReset, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    const verificationCodeModel = getVerificationCodeModel();
    
    const { email } = req.body;

    // Check if user exists
    const user = await userModel.findByEmail(email);
    if (!user) {
      // Don't reveal if user exists or not for security
      res.status(200).json({
        success: true,
        message: 'If an account exists with this email, a password reset code has been sent.',
      });
      return;
    }

    // Only allow password reset for verified users
    if (!user.emailVerified) {
      res.status(403).json({
        success: false,
        error: 'Please verify your email first before resetting your password.',
        code: 'EMAIL_NOT_VERIFIED',
      });
      return;
    }

    // Generate reset code
    const resetCode = generateVerificationCode();

    // Store reset code
    await verificationCodeModel.createPasswordResetCode(email, resetCode);

    // Send password reset email
    try {
      await EmailService.sendPasswordResetCode(email, user.firstName, resetCode);
    } catch (emailError) {
      console.error('Failed to send password reset email:', emailError);
      res.status(500).json({
        success: false,
        error: 'Failed to send password reset email',
        code: 'EMAIL_SEND_FAILED',
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: 'Password reset code has been sent to your email.',
      data: {
        email: user.email,
      },
    });
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to process password reset request',
      code: 'RESET_FAILED',
    });
  }
});

// Reset password endpoint - verifies code and updates password
router.post('/reset-password', validatePasswordResetVerify, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    const verificationCodeModel = getVerificationCodeModel();
    
    const { email, code, newPassword } = req.body;

    // Find reset code
    const resetCode = await verificationCodeModel.findByEmailAndCodeForReset(email, code);
    
    if (!resetCode) {
      res.status(400).json({
        success: false,
        error: 'Invalid or expired reset code',
        code: 'INVALID_CODE',
      });
      return;
    }

    // Find user
    const user = await userModel.findByEmail(email);
    if (!user) {
      res.status(404).json({
        success: false,
        error: 'User not found',
        code: 'USER_NOT_FOUND',
      });
      return;
    }

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Update user password
    await userModel.updatePassword(user.uid, hashedPassword);

    // Mark reset code as used
    await verificationCodeModel.markAsVerified(email, code);

    res.status(200).json({
      success: true,
      message: 'Password has been reset successfully. You can now login with your new password.',
      data: {
        email: user.email,
      },
    });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to reset password',
      code: 'RESET_FAILED',
    });
  }
});

// Validate email endpoint
router.post('/validate-email', validateEmail, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    const { email } = req.body;
    const verified = req.body.verified !== undefined ? req.body.verified : true;

    const user = await userModel.findByEmail(email);

    if (!user) {
      res.status(404).json({
        success: false,
        error: 'User not found',
        code: 'USER_NOT_FOUND',
      });
      return;
    }

    const updated = await userModel.updateEmailVerified(user.uid, verified);

    if (!updated) {
      res.status(500).json({
        success: false,
        error: 'Failed to update email verification status',
        code: 'UPDATE_FAILED',
      });
      return;
    }

    res.status(200).json({
      success: true,
      message: `Email verification status updated to ${verified}`,
      data: {
        email: user.email,
        emailVerified: verified,
      },
    });
  } catch (error) {
    console.error('Email validation error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to validate email',
      code: 'VALIDATION_FAILED',
    });
  }
});

// Get current user endpoint (protected)
router.get('/me', authenticate, async (req: Request, res: Response): Promise<void> => {
  try {
    const userModel = getUserModel();
    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'Unauthorized',
        code: 'UNAUTHORIZED',
      });
      return;
    }

    const user = await userModel.findByUid(req.user.uid);

    if (!user) {
      res.status(404).json({
        success: false,
        error: 'User not found',
        code: 'USER_NOT_FOUND',
      });
      return;
    }

    const userWithoutPassword = await userModel.getUserWithoutPassword(user);

    res.status(200).json({
      success: true,
      data: userWithoutPassword,
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get user',
      code: 'GET_USER_FAILED',
    });
  }
});

export default router;
